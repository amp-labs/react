/* tslint:disable */
/* eslint-disable */
/**
 * Ampersand public API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiProblem,
  BatchUpsertIntegrationsRequest,
  CreateIntegrationRequest,
  InputValidationProblem,
  Integration,
} from '../models';
import {
    ApiProblemFromJSON,
    ApiProblemToJSON,
    BatchUpsertIntegrationsRequestFromJSON,
    BatchUpsertIntegrationsRequestToJSON,
    CreateIntegrationRequestFromJSON,
    CreateIntegrationRequestToJSON,
    InputValidationProblemFromJSON,
    InputValidationProblemToJSON,
    IntegrationFromJSON,
    IntegrationToJSON,
} from '../models';

export interface BatchUpsertIntegrationsOperationRequest {
    projectIdOrName: string;
    batchUpsertIntegrationsRequest: BatchUpsertIntegrationsRequest;
}

export interface CreateIntegrationOperationRequest {
    projectIdOrName: string;
    integration: CreateIntegrationRequest;
}

export interface DeleteIntegrationRequest {
    projectIdOrName: string;
    integrationId: string;
}

export interface GetIntegrationRequest {
    integrationIdOrName: string;
    projectIdOrName: string;
}

export interface ListIntegrationsRequest {
    projectIdOrName: string;
}

/**
 * IntegrationApi - interface
 * 
 * @export
 * @interface IntegrationApiInterface
 */
export interface IntegrationApiInterface {
    /**
     * 
     * @summary Batch upsert a group of integrations
     * @param {string} projectIdOrName The Ampersand project ID or project name.
     * @param {BatchUpsertIntegrationsRequest} batchUpsertIntegrationsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    batchUpsertIntegrationsRaw(requestParameters: BatchUpsertIntegrationsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Integration>>>;

    /**
     * Batch upsert a group of integrations
     */
    batchUpsertIntegrations(requestParameters: BatchUpsertIntegrationsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Integration>>;

    /**
     * 
     * @summary Create a new integration.
     * @param {string} projectIdOrName The Ampersand project ID or project name.
     * @param {CreateIntegrationRequest} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    createIntegrationRaw(requestParameters: CreateIntegrationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Create a new integration.
     */
    createIntegration(requestParameters: CreateIntegrationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary Delete an integration
     * @param {string} projectIdOrName The Ampersand project ID or project name.
     * @param {string} integrationId The integration ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    deleteIntegrationRaw(requestParameters: DeleteIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete an integration
     */
    deleteIntegration(requestParameters: DeleteIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary Get an integration by ID or name
     * @param {string} integrationIdOrName The integration ID or name.
     * @param {string} projectIdOrName The Ampersand project ID or project name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getIntegrationRaw(requestParameters: GetIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Integration>>;

    /**
     * Get an integration by ID or name
     */
    getIntegration(requestParameters: GetIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Integration>;

    /**
     * 
     * @summary List integrations
     * @param {string} projectIdOrName The Ampersand project ID or project name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    listIntegrationsRaw(requestParameters: ListIntegrationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Integration>>>;

    /**
     * List integrations
     */
    listIntegrations(requestParameters: ListIntegrationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Integration>>;

}

/**
 * 
 */
export class IntegrationApi extends runtime.BaseAPI implements IntegrationApiInterface {

    /**
     * Batch upsert a group of integrations
     */
    async batchUpsertIntegrationsRaw(requestParameters: BatchUpsertIntegrationsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Integration>>> {
        if (requestParameters.projectIdOrName === null || requestParameters.projectIdOrName === undefined) {
            throw new runtime.RequiredError('projectIdOrName','Required parameter requestParameters.projectIdOrName was null or undefined when calling batchUpsertIntegrations.');
        }

        if (requestParameters.batchUpsertIntegrationsRequest === null || requestParameters.batchUpsertIntegrationsRequest === undefined) {
            throw new runtime.RequiredError('batchUpsertIntegrationsRequest','Required parameter requestParameters.batchUpsertIntegrationsRequest was null or undefined when calling batchUpsertIntegrations.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = this.configuration.apiKey("X-Api-Key"); // APIKeyHeader authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectIdOrName}/integrations:batch`.replace(`{${"projectIdOrName"}}`, encodeURIComponent(String(requestParameters.projectIdOrName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BatchUpsertIntegrationsRequestToJSON(requestParameters.batchUpsertIntegrationsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IntegrationFromJSON));
    }

    /**
     * Batch upsert a group of integrations
     */
    async batchUpsertIntegrations(requestParameters: BatchUpsertIntegrationsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Integration>> {
        const response = await this.batchUpsertIntegrationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new integration.
     */
    async createIntegrationRaw(requestParameters: CreateIntegrationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectIdOrName === null || requestParameters.projectIdOrName === undefined) {
            throw new runtime.RequiredError('projectIdOrName','Required parameter requestParameters.projectIdOrName was null or undefined when calling createIntegration.');
        }

        if (requestParameters.integration === null || requestParameters.integration === undefined) {
            throw new runtime.RequiredError('integration','Required parameter requestParameters.integration was null or undefined when calling createIntegration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = this.configuration.apiKey("X-Api-Key"); // APIKeyHeader authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectIdOrName}/integrations`.replace(`{${"projectIdOrName"}}`, encodeURIComponent(String(requestParameters.projectIdOrName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateIntegrationRequestToJSON(requestParameters.integration),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new integration.
     */
    async createIntegration(requestParameters: CreateIntegrationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createIntegrationRaw(requestParameters, initOverrides);
    }

    /**
     * Delete an integration
     */
    async deleteIntegrationRaw(requestParameters: DeleteIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectIdOrName === null || requestParameters.projectIdOrName === undefined) {
            throw new runtime.RequiredError('projectIdOrName','Required parameter requestParameters.projectIdOrName was null or undefined when calling deleteIntegration.');
        }

        if (requestParameters.integrationId === null || requestParameters.integrationId === undefined) {
            throw new runtime.RequiredError('integrationId','Required parameter requestParameters.integrationId was null or undefined when calling deleteIntegration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = this.configuration.apiKey("X-Api-Key"); // APIKeyHeader authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectIdOrName}/integrations/{integrationId}`.replace(`{${"projectIdOrName"}}`, encodeURIComponent(String(requestParameters.projectIdOrName))).replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters.integrationId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an integration
     */
    async deleteIntegration(requestParameters: DeleteIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteIntegrationRaw(requestParameters, initOverrides);
    }

    /**
     * Get an integration by ID or name
     */
    async getIntegrationRaw(requestParameters: GetIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Integration>> {
        if (requestParameters.integrationIdOrName === null || requestParameters.integrationIdOrName === undefined) {
            throw new runtime.RequiredError('integrationIdOrName','Required parameter requestParameters.integrationIdOrName was null or undefined when calling getIntegration.');
        }

        if (requestParameters.projectIdOrName === null || requestParameters.projectIdOrName === undefined) {
            throw new runtime.RequiredError('projectIdOrName','Required parameter requestParameters.projectIdOrName was null or undefined when calling getIntegration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = this.configuration.apiKey("X-Api-Key"); // APIKeyHeader authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectIdOrName}/integrations/{integrationIdOrName}`.replace(`{${"integrationIdOrName"}}`, encodeURIComponent(String(requestParameters.integrationIdOrName))).replace(`{${"projectIdOrName"}}`, encodeURIComponent(String(requestParameters.projectIdOrName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IntegrationFromJSON(jsonValue));
    }

    /**
     * Get an integration by ID or name
     */
    async getIntegration(requestParameters: GetIntegrationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Integration> {
        const response = await this.getIntegrationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List integrations
     */
    async listIntegrationsRaw(requestParameters: ListIntegrationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Integration>>> {
        if (requestParameters.projectIdOrName === null || requestParameters.projectIdOrName === undefined) {
            throw new runtime.RequiredError('projectIdOrName','Required parameter requestParameters.projectIdOrName was null or undefined when calling listIntegrations.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Api-Key"] = this.configuration.apiKey("X-Api-Key"); // APIKeyHeader authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/projects/{projectIdOrName}/integrations`.replace(`{${"projectIdOrName"}}`, encodeURIComponent(String(requestParameters.projectIdOrName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IntegrationFromJSON));
    }

    /**
     * List integrations
     */
    async listIntegrations(requestParameters: ListIntegrationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Integration>> {
        const response = await this.listIntegrationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
